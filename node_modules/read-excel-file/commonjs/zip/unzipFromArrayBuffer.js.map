{"version":3,"file":"unzipFromArrayBuffer.js","names":["_fflate","require","unzipFromArrayBuffer","input","options","unzipFromArrayBufferUsingFunction","unzipAsync","_ref","arguments","length","undefined","filter","unzip","isAsync","Uint8Array","file","path","name","archive","Promise","resolve","reject","error","files"],"sources":["../../source/zip/unzipFromArrayBuffer.js"],"sourcesContent":["// `fflate` readme is too complicated:\r\n// https://github.com/101arrowz/fflate/issues/251\r\n// I just used whatever approach seemed to work.\r\n//\r\n// It was a choice between \"syncrhonous\" (blocking) unzip via `unzipSync()`\r\n// and \"asynchronous\" (non-blocking) unzip via `unzip()`.\r\n//\r\n// In the readme they say that using \"asynchronous\" API  will cause the compression or decompression\r\n// run in a separate thread by using Web (or Node) Workers, so it won't block the main thread.\r\n// Yet, they also say that there is an initial overhead to using workers of about 50ms for each\r\n// asynchronous function. For small (under about 50kB) payloads, they say that the \"asynchronous\" API\r\n// will be much slower compared to the \"synchronous\" one. However, when compressing larger files\r\n// or multiple files at once, the \"synchronous\" API causes the main thread to hang for too long,\r\n// and the \"asynchronous\" API is an order of magnitude better.\r\n//\r\nimport { unzip } from 'fflate'\r\n\r\n/**\r\n * Reads `*.zip` file contents. Ignores anything besides `.xml` or `.xml.rels` files.\r\n * @param  {ArrayBuffer} input\r\n * @return {Promise<Record<string,Uint8Array>>} Resolves to an object holding `*.zip` file entries.\r\n */\r\nexport default function unzipFromArrayBuffer(input, options) {\r\n\treturn unzipFromArrayBufferUsingFunction(input, options, unzipAsync, true)\r\n}\r\n\r\n/**\r\n * Reads `*.zip` file contents. Ignores anything besides `.xml` or `.xml.rels` files.\r\n * @param  {ArrayBuffer} input\r\n * @param  {(ArrayBuffer) => Record<string, Uint8Array> | Promise<Record<string, Uint8Array>>} unzip\r\n * @param  {boolean} isAsync — Should be `true` when `unzip()` returns a `Promise`, `false` otherwise.\r\n * @return {Promise<Record<string,Uint8Array>>|Record<string,Uint8Array>} Resolves to an object holding `*.zip` file entries.\r\n */\r\nexport function unzipFromArrayBufferUsingFunction(input, { filter } = {}, unzip, isAsync) {\r\n\t// Read the `.zip` archive.\r\n\t// `result` is either `object` or `Promise<object>`\r\n\treturn unzip(new Uint8Array(input), {\r\n\t\t// Ignore certain types of files.\r\n\t\tfilter: (file) => {\r\n\t\t\tif (filter) {\r\n\t\t\t\treturn filter({\r\n\t\t\t\t\tpath: file.name\r\n\t\t\t\t})\r\n\t\t\t}\r\n\t\t\treturn true\r\n\t\t}\r\n\t})\r\n}\r\n\r\nfunction unzipAsync(archive) {\r\n  return new Promise((resolve, reject) => {\r\n\t\t// `unzip()` will resort to \"synchronous\" decompression in two edge cases:\r\n    // * When the archive size is less than `512KB`.\r\n    // * When the data is barely compressed, i.e. the compression ratio is less than 20% reduction in size.\r\n    unzip(archive, (error, files) => {\r\n      if (error) {\r\n        reject(error)\r\n      } else {\r\n        resolve(files)\r\n      }\r\n    })\r\n  })\r\n}"],"mappings":";;;;;;;AAeA,IAAAA,OAAA,GAAAC,OAAA;AAfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACe,SAASC,oBAAoBA,CAACC,KAAK,EAAEC,OAAO,EAAE;EAC5D,OAAOC,iCAAiC,CAACF,KAAK,EAAEC,OAAO,EAAEE,UAAU,EAAE,IAAI,CAAC;AAC3E;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASD,iCAAiCA,CAACF,KAAK,EAAmC;EAAA,IAAAI,IAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAApB,CAAC,CAAC;IAAbG,OAAM,GAAAJ,IAAA,CAANI,MAAM;EAAA,IAASC,KAAK,GAAAJ,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EAAA,IAAEG,OAAO,GAAAL,SAAA,CAAAC,MAAA,OAAAD,SAAA,MAAAE,SAAA;EACvF;EACA;EACA,OAAOE,KAAK,CAAC,IAAIE,UAAU,CAACX,KAAK,CAAC,EAAE;IACnC;IACAQ,MAAM,EAAE,SAAAA,OAACI,IAAI,EAAK;MACjB,IAAIJ,OAAM,EAAE;QACX,OAAOA,OAAM,CAAC;UACbK,IAAI,EAAED,IAAI,CAACE;QACZ,CAAC,CAAC;MACH;MACA,OAAO,IAAI;IACZ;EACD,CAAC,CAAC;AACH;AAEA,SAASX,UAAUA,CAACY,OAAO,EAAE;EAC3B,OAAO,IAAIC,OAAO,CAAC,UAACC,OAAO,EAAEC,MAAM,EAAK;IACxC;IACE;IACA;IACA,IAAAT,aAAK,EAACM,OAAO,EAAE,UAACI,KAAK,EAAEC,KAAK,EAAK;MAC/B,IAAID,KAAK,EAAE;QACTD,MAAM,CAACC,KAAK,CAAC;MACf,CAAC,MAAM;QACLF,OAAO,CAACG,KAAK,CAAC;MAChB;IACF,CAAC,CAAC;EACJ,CAAC,CAAC;AACJ"}