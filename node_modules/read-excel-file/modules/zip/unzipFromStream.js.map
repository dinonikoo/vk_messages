{"version":3,"file":"unzipFromStream.js","names":["Buffer","unzip","unzipFromStream","stream","_ref","arguments","length","undefined","filter","files","Promise","resolve","reject","promises","errored","onError","error","on","pipe","Parse","all","then","entry","ignore","type","path","autodrain","chunks","push","data","concat"],"sources":["../../source/zip/unzipFromStream.js"],"sourcesContent":["import { Buffer } from 'buffer'\r\n\r\n// `unzipper` has a bug when it doesn't include \"@aws-sdk/client-s3\" package in the `dependencies`\r\n// which causes some \"bundlers\" throw an error.\r\n// https://github.com/ZJONSSON/node-unzipper/issues/330\r\n//\r\n// One workaround is to install \"@aws-sdk/client-s3\" package manually, which would still lead to increased bundle size.\r\n// If the code is bundled for server-side-use only, that is will not be used in a web browser,\r\n// then the increased bundle size would not be an issue.\r\n//\r\n// Another workaround could be to \"alias\" \"@aws-sdk/client-s3\" package in a \"bundler\" configuration file\r\n// with a path to a `*.js` file containing just \"export default null\". But that kind of a workaround would also\r\n// result in errors when using other packages that `import` anything from \"@aws-sdk/client-s3\" package,\r\n// so it's not really a workaround but more of a ticking bomb.\r\n//\r\nimport unzip from 'unzipper'\r\n\r\n// Althernatively, it could use `fflate` if someone writes an example of handling a Node.js stream.\r\n// https://github.com/101arrowz/fflate/issues/251\r\n\r\n/**\r\n * Reads `*.zip` file contents.\r\n * @param  {Stream} stream\r\n * @return {Promise<Record<string,Buffer>>} Resolves to an object holding `*.zip` file entries. P.S. `Buffer` is a `Uint8Array`.\r\n */\r\nexport default function unzipFromStream(stream, { filter } = {}) {\r\n\t// The `files` object stores the files and their contents.\r\n\tconst files = {}\r\n\r\n\treturn new Promise((resolve, reject) => {\r\n\t\tconst promises = []\r\n\r\n\t\tlet errored = false\r\n\r\n\t\tconst onError = (error) => {\r\n\t\t\tif (!errored) {\r\n\t\t\t\terrored = true\r\n\t\t\t\treject(error)\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tstream\r\n\t\t\t// This first \"error\" listener catches the original stream errors.\r\n\t\t\t//\r\n\t\t\t// That's because the .pipe() method does not automatically propagate errors\r\n\t\t\t// from a source (input) stream to the destination stream or the end of the pipeline.\r\n\t\t\t// You would need to attach an 'error' event handler to each stream in the chain.\r\n\t\t\t//\r\n\t\t\t// A more convenient alternative would be to use `stream.pipeline()` function:\r\n\t\t\t// `pipeline(stream1, stream2, (error) => { ... })`\r\n\t\t\t//\r\n\t\t\t.on('error', onError)\r\n\t\t\t// Pipe the input stream through the unzipper stream.\r\n\t\t\t.pipe(unzip.Parse())\r\n\t\t\t// This second \"error\" listener catches the unzipper stream errors.\r\n\t\t\t//\r\n\t\t\t// That's because the .pipe() method does not automatically propagate errors\r\n\t\t\t// from a source (input) stream to the destination stream or the end of the pipeline.\r\n\t\t\t// You would need to attach an 'error' event handler to each stream in the chain.\r\n\t\t\t//\r\n\t\t\t// A more convenient alternative would be to use `stream.pipeline()` function:\r\n\t\t\t// `pipeline(stream1, stream2, (error) => { ... })`\r\n\t\t\t//\r\n\t\t\t.on('error', onError)\r\n\t\t\t// The unzipper stream is closed when all `entries` have been reported.\r\n\t\t\t.on('finish', () => {\r\n\t\t\t\tif (!errored) {\r\n\t\t\t\t\t// Wait for all `entries` to be read.\r\n\t\t\t\t\t// The second argument of `.then()` function is not required\r\n\t\t\t\t\t// but I didn't remove it just to potentially prevent any potential silly bugs\r\n\t\t\t\t\t// in case of some potential changes in some potential future.\r\n\t\t\t\t\tPromise.all(promises).then(() => {\r\n\t\t\t\t\t\tresolve(files)\r\n\t\t\t\t\t}, onError)\r\n\t\t\t\t}\r\n\t\t\t})\r\n\t\t\t.on('entry', (entry) => {\r\n\t\t\t\t// See if this file should be ignored.\r\n\t\t\t\tlet ignore = false\r\n\t\t\t\t// `entry.type` could be 'Directory' or 'File'.\r\n\t\t\t\t// Ignore anything except files.\r\n\t\t\t\tif (entry.type === 'Directory') {\r\n\t\t\t\t\tignore = true\r\n\t\t\t\t}\r\n\t\t\t\tif (errored) {\r\n\t\t\t\t\tignore = true\r\n\t\t\t\t}\r\n\t\t\t\tif (filter) {\r\n\t\t\t\t\tif (!filter({ path: entry.path })) {\r\n\t\t\t\t\t\tignore = true\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\r\n\t\t\t\t// If this file should be ignored.\r\n\t\t\t\tif (ignore) {\r\n\t\t\t\t\t// Call `entry.autodrain()` when you do not intend to process a specific `entry`'s raw data.\r\n\t\t\t\t\t// Otherwise, if an `entry` is not consumed (via .pipe(), .buffer(), or .autodrain()),\r\n\t\t\t\t\t// the stream will halt, preventing further file processing.\r\n\t\t\t\t\tentry.autodrain().on('error', onError)\r\n\t\t\t\t\treturn\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst chunks = []\r\n\r\n\t\t\t\tpromises.push(new Promise((resolve) => {\r\n\t\t\t\t\t// `entry` seems to be a generic Node.js stream.\r\n\t\t\t\t\t// `entry.pipe()` pipes the file contents to a stream.\r\n\t\t\t\t\t// `entry.stream()` returns a readable stream.\r\n\t\t\t\t\t// `entry.buffer()` returns a promise that resolves to a `Buffer` with the file contents.\r\n\t\t\t\t\tentry\r\n\t\t\t\t\t\t.on('data', (data) => {\r\n\t\t\t\t\t\t\tchunks.push(data)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on('error', (error) => {\r\n\t\t\t\t\t\t\tonError(error)\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t.on('finish', () => {\r\n\t\t\t\t\t\t\tfiles[entry.path] = Buffer.concat(chunks)\r\n\t\t\t\t\t\t\tresolve()\r\n\t\t\t\t\t\t})\r\n\t\t\t\t}))\r\n\t\t\t})\r\n\t})\r\n}"],"mappings":"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"}