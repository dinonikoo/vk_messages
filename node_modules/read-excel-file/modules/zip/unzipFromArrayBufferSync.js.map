{"version":3,"file":"unzipFromArrayBufferSync.js","names":["unzipSync","unzipFromArrayBufferUsingFunction","unzipFromArrayBufferSync","input","options"],"sources":["../../source/zip/unzipFromArrayBufferSync.js"],"sourcesContent":["// `fflate` readme is too complicated:\r\n// https://github.com/101arrowz/fflate/issues/251\r\n// I just used whatever approach seemed to work.\r\n//\r\n// It was a choice between \"syncrhonous\" (blocking) unzip via `unzipSync()`\r\n// and \"asynchronous\" (non-blocking) unzip via `unzip()`.\r\n//\r\n// In the readme they say that using \"asynchronous\" API  will cause the compression or decompression\r\n// run in a separate thread by using Web (or Node) Workers, so it won't block the main thread.\r\n// Yet, they also say that there is an initial overhead to using workers of about 50ms for each\r\n// asynchronous function. For small (under about 50kB) payloads, they say that the \"asynchronous\" API\r\n// will be much slower compared to the \"synchronous\" one. However, when compressing larger files\r\n// or multiple files at once, the \"synchronous\" API causes the main thread to hang for too long,\r\n// and the \"asynchronous\" API is an order of magnitude better.\r\n//\r\nimport { unzipSync } from 'fflate'\r\n\r\nimport { unzipFromArrayBufferUsingFunction } from './unzipFromArrayBuffer.js'\r\n\r\n/**\r\n * Reads `*.zip` file contents. Ignores anything besides `.xml` or `.xml.rels` files.\r\n * @param  {ArrayBuffer} input\r\n * @return {Record<string,Uint8Array>} An object holding `*.zip` file entries.\r\n */\r\nexport default function unzipFromArrayBufferSync(input, options) {\r\n\treturn unzipFromArrayBufferUsingFunction(input, options, unzipSync, true)\r\n}"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAAS,QAAQ,QAAQ;AAElC,SAASC,iCAAiC,QAAQ,2BAA2B;;AAE7E;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,wBAAwBA,CAACC,KAAK,EAAEC,OAAO,EAAE;EAChE,OAAOH,iCAAiC,CAACE,KAAK,EAAEC,OAAO,EAAEJ,SAAS,EAAE,IAAI,CAAC;AAC1E"}